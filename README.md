# Microservice Architecture Simulation

## Оглавление
- [Описание](#описание)
- [Основная идея симуляции](#основная-идея-симуляции)
- [Компоненты системы](#компоненты-системы)
- [Расширенные возможности](#расширенные-возможности)
- [Структура проекта](#структура-проекта)
- [Установка и запуск](#установка-и-запуск)
- [Настройка параметров](#настройка-параметров)
- [Визуализация с помощью Streamlit](#визуализация-с-помощью-streamlit)
- [Пример использования](#пример-использования)

## Описание
Данный проект представляет собой дискретно-событийную симуляцию микросервисной архитектуры. Он демонстрирует, как микросервисы (P, Q, S, T) взаимодействуют между собой, обрабатывают запросы (чтение/запись), сталкиваются с ошибками и задержками. Модель позволяет варьировать параметры для изучения производительности, устойчивости и сценариев сбоев.

## Основная идея симуляции

**ServiceP (клиенты):** Генерируют запросы на чтение и запись с заданной интенсивностью. Можно запускать несколько процессов P (несколько пользователей), чтобы сымитировать нагрузку.

**ServiceQ (промежуточный сервис):** Принимает запрос от P и обращается к T и S. При записи сначала записывает в T, затем в S. При чтении пытается прочитать из T, при неудаче — из S. Обрабатывает таймауты и ошибки, возвращая "OK" или "ERROR: ...".

**ServiceT (кеш):** Хранит данные в памяти, мгновенно отвечая, но с вероятностью отказа.

**ServiceS (хранилище):** Медленнее и сложнее, с ограниченной конкуренцией и вероятностью отказа. Может занимать время на операции чтения и записи, а также может иметь очереди запросов.

## Компоненты системы

### ServiceP:
- Настраиваемая интенсивность запросов (`mean_interarrival`, `arrival_process`), вероятность чтения (`read_probability`), и количество запросов (`num_requests`).
- Возможность запускать несколько P, чтобы имитировать множество пользователей, генерирующих нагрузку одновременно.

### ServiceQ:
- Обрабатывает запросы от P.
- Обращается к T (быстрая кеширующая система) и S (постоянное хранилище).
- Переводит внутренние исключения T и S в "ERROR: ..." для P, обрабатывая таймауты и сбои.

### ServiceT и ServiceS:
- Вероятность отказа, время отклика, конкурентность (для S).
- S может иметь очередь и ограничение по числу параллельных операций, что позволяет проверить, как система справляется с высокими нагрузками.

## Расширенные возможности
- Возможность задать несколько пользователей (`num_users`), чтобы генерировать запросы параллельно. Это создает ситуацию, когда несколько запросов приходят почти одновременно, повышая вероятность перегрузки очереди в S.
- Настройка интенсивности потока заявок (пуассоновский или фиксированный интервал).
- Возможность задавать параметры отказов и задержек для T и S, чтобы имитировать реальные сценарии сбоев.
- Сбор статистики по количеству успешных и неуспешных запросов, среднему времени ответа и подробным деталям каждого запроса.

## Структура проекта
```
micro_service_architecture_analysis/
├── README.md
├── requirements.txt
├── config.yaml
├── main.py
├── app.py          # Streamlit-приложение для визуализации
├── services/
│   ├── __init__.py
│   ├── service_p.py
│   ├── service_q.py
│   ├── service_s.py
│   └── service_t.py
└── tests/
    ├── test_service_q.py
    ├── test_service_s.py
    └── test_service_t.py
```
- `main.py`: основной скрипт симуляции (`run_simulation(config)`)
- `app.py`: веб-интерфейс на Streamlit для запуска симуляции и визуализации результатов
- `services/`: реализация служб (P, Q, S, T)
- `config.yaml`: пример файла конфигурации для настройки параметров.
- `tests/`: тесты для отдельных компонентов.

## Установка и запуск

1. Клонировать репозиторий и перейти в директорию проекта.
2. Создать и активировать виртуальное окружение:

```bash
python3 -m venv venv
source venv/bin/activate   # Для Linux/Mac
# или venv\Scripts\activate для Windows
```

3. Установить зависимости:

```bash
pip install -r requirements.txt
```

4. Запустить симуляцию с параметрами по умолчанию:

```bash
python main.py
```

Вывод покажет статистику по количеству успехов, ошибок и среднему времени.

## Настройка параметров

Все параметры можно задать в `config.yaml` или через интерфейс `app.py`. Основные параметры:

- **P:** `arrival_process`, `mean_interarrival`, `read_probability`, `num_requests`, `num_users`
- **Q:** `response_timeout`
- **T:** `read_failure_probability`, `write_failure_probability`
- **S:** `read_failure_probability`, `write_failure_probability`, `max_write_time`, `max_read_time`, `concurrency_limit`

Изменяя параметры, вы можете смоделировать различные сценарии нагрузки, отказов и задержек.

## Визуализация с помощью Streamlit

Для запуска веб-интерфейса:

```bash
streamlit run app.py
```

Откроется браузер с интерфейсом. Вы можете настраивать параметры в `app.py`, запускать симуляцию, смотреть на графики (гистограммы, пай-чарты, накопленные ошибки по времени, сравнения сценариев).

## Пример использования

1. Задать в `config.yaml` `num_users=5`, чтобы запустить 5 пользователей, и увеличить `num_requests`, чтобы генерировать большую нагрузку.
2. Запустить `python main.py` или перейти в `app.py` (Streamlit интерфейс), выбрать `num_users` и другие параметры.
3. Анализировать результаты:
   - Если `S.concurrency_limit` мало, вы увидите рост очередей, увеличение времени ответа и количества ошибок.
   - Если T часто отказывает, записи будут чаще падать.
   - Меняя `mean_interarrival` при пуассоновском процессе, вы можете проверить зависимость нагрузки от интенсивности потока заявок.

Данный проект позволит вам экспериментировать с различными настройками микросервисов, визуализировать результаты и понимать поведение распределенной системы под нагрузкой и при сбоях.